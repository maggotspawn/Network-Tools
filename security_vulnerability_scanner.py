#!/usr/bin/env python3
"""
Security Vulnerability Scanner - GUI Version
A comprehensive tool to scan systems for common security vulnerabilities
"""

import os
import sys
import socket
import platform
import subprocess
import json
import threading
from datetime import datetime
from pathlib import Path
import re
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog

class SecurityScanner:
    def __init__(self, callback=None):
        self.callback = callback
        self.results = {
            "scan_time": datetime.now().isoformat(),
            "system_info": {},
            "vulnerabilities": [],
            "warnings": [],
            "recommendations": []
        }
        
    def log(self, message):
        """Send log message to callback"""
        if self.callback:
            self.callback(message)
    
    def scan_system_info(self):
        """Gather basic system information"""
        self.log("[*] Gathering system information...")
        self.results["system_info"] = {
            "platform": platform.system(),
            "platform_release": platform.release(),
            "platform_version": platform.version(),
            "architecture": platform.machine(),
            "hostname": socket.gethostname(),
            "python_version": platform.python_version()
        }
        
    def check_open_ports(self, ports_to_check=None):
        """Check for open ports that might be vulnerable"""
        self.log("[*] Checking for open ports...")
        if ports_to_check is None:
            ports_to_check = [21, 22, 23, 25, 80, 443, 3306, 3389, 5432, 8080]
        
        open_ports = []
        for port in ports_to_check:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex(('127.0.0.1', port))
            if result == 0:
                open_ports.append(port)
            sock.close()
        
        if open_ports:
            self.results["warnings"].append({
                "type": "open_ports",
                "severity": "medium",
                "description": f"Open ports detected: {open_ports}",
                "recommendation": "Review if these services need to be exposed"
            })
    
    def check_weak_permissions(self, paths_to_check=None):
        """Check for files with weak permissions"""
        self.log("[*] Checking file permissions...")
        if platform.system() != "Windows":
            if paths_to_check is None:
                paths_to_check = [
                    "/etc/passwd",
                    "/etc/shadow",
                    os.path.expanduser("~/.ssh"),
                    os.path.expanduser("~/.bashrc")
                ]
            
            for path in paths_to_check:
                if os.path.exists(path):
                    stat_info = os.stat(path)
                    perms = oct(stat_info.st_mode)[-3:]
                    
                    if perms[2] in ['2', '3', '6', '7']:
                        self.results["vulnerabilities"].append({
                            "type": "weak_permissions",
                            "severity": "high",
                            "path": path,
                            "permissions": perms,
                            "description": f"World-writable permissions on {path}"
                        })
    
    def check_password_policy(self):
        """Check for weak password policies (Linux)"""
        self.log("[*] Checking password policies...")
        if platform.system() == "Linux":
            try:
                with open("/etc/login.defs", "r") as f:
                    content = f.read()
                    if "PASS_MAX_DAYS" in content:
                        max_days = re.search(r'PASS_MAX_DAYS\s+(\d+)', content)
                        if max_days and int(max_days.group(1)) > 90:
                            self.results["warnings"].append({
                                "type": "password_policy",
                                "severity": "medium",
                                "description": "Password expiration period is too long",
                                "recommendation": "Set PASS_MAX_DAYS to 90 or less"
                            })
            except (PermissionError, FileNotFoundError):
                pass
    
    def check_firewall_status(self):
        """Check if firewall is enabled"""
        self.log("[*] Checking firewall status...")
        system = platform.system()
        
        try:
            if system == "Linux":
                result = subprocess.run(['ufw', 'status'], 
                                      capture_output=True, text=True, timeout=5)
                if 'inactive' in result.stdout.lower():
                    self.results["vulnerabilities"].append({
                        "type": "firewall",
                        "severity": "high",
                        "description": "Firewall (UFW) is not active",
                        "recommendation": "Enable firewall with 'sudo ufw enable'"
                    })
            elif system == "Windows":
                result = subprocess.run(['netsh', 'advfirewall', 'show', 'allprofiles'], 
                                      capture_output=True, text=True, timeout=5)
                if 'State' in result.stdout and 'OFF' in result.stdout:
                    self.results["vulnerabilities"].append({
                        "type": "firewall",
                        "severity": "high",
                        "description": "Windows Firewall is disabled",
                        "recommendation": "Enable Windows Firewall"
                    })
        except (subprocess.TimeoutExpired, FileNotFoundError, PermissionError):
            self.results["warnings"].append({
                "type": "firewall_check",
                "severity": "low",
                "description": "Could not verify firewall status"
            })
    
    def check_outdated_software(self):
        """Check for outdated Python packages"""
        self.log("[*] Checking for outdated packages...")
        try:
            result = subprocess.run([sys.executable, '-m', 'pip', 'list', '--outdated'], 
                                  capture_output=True, text=True, timeout=30)
            if result.stdout and len(result.stdout.split('\n')) > 2:
                self.results["warnings"].append({
                    "type": "outdated_packages",
                    "severity": "medium",
                    "description": "Outdated Python packages detected",
                    "recommendation": "Update packages with 'pip install --upgrade <package>'"
                })
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
    
    def check_ssh_config(self):
        """Check SSH configuration for security issues"""
        self.log("[*] Checking SSH configuration...")
        ssh_config_path = "/etc/ssh/sshd_config"
        
        if os.path.exists(ssh_config_path):
            try:
                with open(ssh_config_path, 'r') as f:
                    config = f.read()
                    
                    if re.search(r'^\s*PermitRootLogin\s+yes', config, re.MULTILINE):
                        self.results["vulnerabilities"].append({
                            "type": "ssh_config",
                            "severity": "high",
                            "description": "SSH root login is enabled",
                            "recommendation": "Set 'PermitRootLogin no' in sshd_config"
                        })
                    
                    if re.search(r'^\s*PasswordAuthentication\s+yes', config, re.MULTILINE):
                        self.results["warnings"].append({
                            "type": "ssh_config",
                            "severity": "medium",
                            "description": "SSH password authentication is enabled",
                            "recommendation": "Consider using key-based authentication"
                        })
            except PermissionError:
                pass
    
    def check_environment_secrets(self):
        """Check for potential secrets in environment variables"""
        self.log("[*] Checking environment variables...")
        sensitive_patterns = ['password', 'secret', 'key', 'token', 'api']
        
        for key, value in os.environ.items():
            key_lower = key.lower()
            if any(pattern in key_lower for pattern in sensitive_patterns):
                self.results["warnings"].append({
                    "type": "environment_secrets",
                    "severity": "medium",
                    "description": f"Potential secret in environment variable: {key}",
                    "recommendation": "Use secret management tools"
                })
    
    def generate_recommendations(self):
        """Generate security recommendations"""
        self.results["recommendations"] = [
            "Keep your system and software updated regularly",
            "Use strong, unique passwords for all accounts",
            "Enable two-factor authentication where available",
            "Regularly backup important data",
            "Use encryption for sensitive data",
            "Monitor system logs for suspicious activity",
            "Limit user privileges (principle of least privilege)",
            "Disable unused services and ports"
        ]
    
    def run_scan(self):
        """Run all security checks"""
        self.log("="*60)
        self.log("Security Vulnerability Scanner - Starting Scan")
        self.log("="*60 + "\n")
        
        self.scan_system_info()
        self.check_open_ports()
        self.check_weak_permissions()
        self.check_password_policy()
        self.check_firewall_status()
        self.check_outdated_software()
        self.check_ssh_config()
        self.check_environment_secrets()
        self.generate_recommendations()
        
        self.log("\n" + "="*60)
        self.log("Scan Complete!")
        self.log("="*60 + "\n")
        
        return self.results


class SecurityScannerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Security Vulnerability Scanner")
        self.root.geometry("1000x700")
        self.root.minsize(800, 600)
        
        # Modern color scheme
        self.bg_color = "#1e1e1e"
        self.fg_color = "#ffffff"
        self.accent_color = "#007acc"
        self.success_color = "#4ec9b0"
        self.warning_color = "#ce9178"
        self.error_color = "#f48771"
        self.text_bg = "#252526"
        
        self.root.configure(bg=self.bg_color)
        self.scanner = None
        self.scan_results = None
        
        self.setup_styles()
        self.create_widgets()
        
    def setup_styles(self):
        """Setup modern ttk styles"""
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure('TFrame', background=self.bg_color)
        style.configure('TLabel', background=self.bg_color, foreground=self.fg_color, font=('Segoe UI', 10))
        style.configure('Title.TLabel', font=('Segoe UI', 16, 'bold'))
        style.configure('TButton', font=('Segoe UI', 10), padding=10)
        style.map('TButton', background=[('active', self.accent_color)])
        
    def create_widgets(self):
        """Create GUI widgets"""
        # Header
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill=tk.X, padx=20, pady=20)
        
        title_label = ttk.Label(header_frame, text="🔒 Security Vulnerability Scanner", 
                               style='Title.TLabel')
        title_label.pack(side=tk.LEFT)
        
        # Button frame
        button_frame = ttk.Frame(self.root)
        button_frame.pack(fill=tk.X, padx=20, pady=(0, 10))
        
        self.scan_btn = tk.Button(button_frame, text="▶ Start Scan", command=self.start_scan,
                                  bg=self.accent_color, fg=self.fg_color, font=('Segoe UI', 10, 'bold'),
                                  relief=tk.FLAT, padx=20, pady=10, cursor="hand2")
        self.scan_btn.pack(side=tk.LEFT, padx=5)
        
        self.save_btn = tk.Button(button_frame, text="💾 Save Report", command=self.save_report,
                                 bg="#3c3c3c", fg=self.fg_color, font=('Segoe UI', 10),
                                 relief=tk.FLAT, padx=20, pady=10, cursor="hand2", state=tk.DISABLED)
        self.save_btn.pack(side=tk.LEFT, padx=5)
        
        self.copy_btn = tk.Button(button_frame, text="📋 Copy Selected", command=self.copy_text,
                                 bg="#3c3c3c", fg=self.fg_color, font=('Segoe UI', 10),
                                 relief=tk.FLAT, padx=20, pady=10, cursor="hand2")
        self.copy_btn.pack(side=tk.LEFT, padx=5)
        
        self.clear_btn = tk.Button(button_frame, text="🗑 Clear", command=self.clear_output,
                                  bg="#3c3c3c", fg=self.fg_color, font=('Segoe UI', 10),
                                  relief=tk.FLAT, padx=20, pady=10, cursor="hand2")
        self.clear_btn.pack(side=tk.LEFT, padx=5)
        
        # Notebook for tabs
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))
        
        # Scan output tab
        output_frame = ttk.Frame(self.notebook)
        self.notebook.add(output_frame, text="  Scan Output  ")
        
        self.output_text = scrolledtext.ScrolledText(output_frame, wrap=tk.WORD,
                                                     bg=self.text_bg, fg=self.fg_color,
                                                     insertbackground=self.fg_color,
                                                     font=('Consolas', 10),
                                                     relief=tk.FLAT, padx=10, pady=10)
        self.output_text.pack(fill=tk.BOTH, expand=True)
        
        # Results tab
        results_frame = ttk.Frame(self.notebook)
        self.notebook.add(results_frame, text="  Results Summary  ")
        
        self.results_text = scrolledtext.ScrolledText(results_frame, wrap=tk.WORD,
                                                      bg=self.text_bg, fg=self.fg_color,
                                                      insertbackground=self.fg_color,
                                                      font=('Segoe UI', 10),
                                                      relief=tk.FLAT, padx=10, pady=10)
        self.results_text.pack(fill=tk.BOTH, expand=True)
        
        # Configure text tags for colors
        self.output_text.tag_configure("info", foreground=self.accent_color)
        self.output_text.tag_configure("success", foreground=self.success_color)
        self.output_text.tag_configure("warning", foreground=self.warning_color)
        self.output_text.tag_configure("error", foreground=self.error_color)
        
        self.results_text.tag_configure("high", foreground=self.error_color, font=('Segoe UI', 10, 'bold'))
        self.results_text.tag_configure("medium", foreground=self.warning_color, font=('Segoe UI', 10, 'bold'))
        self.results_text.tag_configure("low", foreground=self.success_color, font=('Segoe UI', 10, 'bold'))
        
        # Status bar
        self.status_label = ttk.Label(self.root, text="Ready to scan", relief=tk.FLAT)
        self.status_label.pack(side=tk.BOTTOM, fill=tk.X, padx=20, pady=(0, 10))
        
        # Setup right-click context menu
        self.setup_context_menu()
        
    def setup_context_menu(self):
        """Setup right-click context menu"""
        self.context_menu = tk.Menu(self.root, tearoff=0, bg=self.text_bg, fg=self.fg_color)
        self.context_menu.add_command(label="Cut", command=self.cut_text)
        self.context_menu.add_command(label="Copy", command=self.copy_text)
        self.context_menu.add_command(label="Paste", command=self.paste_text)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="Select All", command=self.select_all)
        
        self.output_text.bind("<Button-3>", self.show_context_menu)
        self.results_text.bind("<Button-3>", self.show_context_menu)
        
    def show_context_menu(self, event):
        """Show context menu on right-click"""
        try:
            self.context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.context_menu.grab_release()
    
    def cut_text(self):
        """Cut selected text"""
        widget = self.root.focus_get()
        if isinstance(widget, (tk.Text, scrolledtext.ScrolledText)):
            try:
                widget.event_generate("<<Cut>>")
            except tk.TclError:
                pass
    
    def copy_text(self):
        """Copy selected text"""
        widget = self.root.focus_get()
        if isinstance(widget, (tk.Text, scrolledtext.ScrolledText)):
            try:
                widget.event_generate("<<Copy>>")
            except tk.TclError:
                pass
    
    def paste_text(self):
        """Paste text from clipboard"""
        widget = self.root.focus_get()
        if isinstance(widget, (tk.Text, scrolledtext.ScrolledText)):
            try:
                widget.event_generate("<<Paste>>")
            except tk.TclError:
                pass
    
    def select_all(self):
        """Select all text"""
        widget = self.root.focus_get()
        if isinstance(widget, (tk.Text, scrolledtext.ScrolledText)):
            widget.tag_add(tk.SEL, "1.0", tk.END)
            widget.mark_set(tk.INSERT, "1.0")
            widget.see(tk.INSERT)
    
    def log_message(self, message):
        """Add message to output text"""
        self.output_text.insert(tk.END, message + "\n")
        self.output_text.see(tk.END)
        self.root.update_idletasks()
    
    def start_scan(self):
        """Start security scan in separate thread"""
        self.scan_btn.config(state=tk.DISABLED, text="⏳ Scanning...")
        self.save_btn.config(state=tk.DISABLED)
        self.clear_output()
        self.status_label.config(text="Scanning system...")
        
        def scan_thread():
            self.scanner = SecurityScanner(callback=self.log_message)
            self.scan_results = self.scanner.run_scan()
            self.root.after(0, self.display_results)
        
        thread = threading.Thread(target=scan_thread, daemon=True)
        thread.start()
    
    def display_results(self):
        """Display scan results"""
        self.scan_btn.config(state=tk.NORMAL, text="▶ Start Scan")
        self.save_btn.config(state=tk.NORMAL)
        
        if not self.scan_results:
            return
        
        self.results_text.delete(1.0, tk.END)
        
        # System Info
        self.results_text.insert(tk.END, "═══ SYSTEM INFORMATION ═══\n\n", "high")
        for key, value in self.scan_results["system_info"].items():
            self.results_text.insert(tk.END, f"{key}: {value}\n")
        
        # Vulnerabilities
        self.results_text.insert(tk.END, "\n═══ VULNERABILITIES ═══\n\n", "high")
        if self.scan_results["vulnerabilities"]:
            for i, vuln in enumerate(self.scan_results["vulnerabilities"], 1):
                severity_tag = vuln['severity']
                self.results_text.insert(tk.END, f"{i}. ", "")
                self.results_text.insert(tk.END, f"[{vuln['severity'].upper()}]", severity_tag)
                self.results_text.insert(tk.END, f" {vuln['type']}\n")
                self.results_text.insert(tk.END, f"   Description: {vuln['description']}\n")
                if 'recommendation' in vuln:
                    self.results_text.insert(tk.END, f"   Recommendation: {vuln['recommendation']}\n")
                self.results_text.insert(tk.END, "\n")
        else:
            self.results_text.insert(tk.END, "✓ No critical vulnerabilities found.\n", "success")
        
        # Warnings
        self.results_text.insert(tk.END, "\n═══ WARNINGS ═══\n\n", "medium")
        if self.scan_results["warnings"]:
            for i, warning in enumerate(self.scan_results["warnings"], 1):
                severity_tag = warning['severity']
                self.results_text.insert(tk.END, f"{i}. ", "")
                self.results_text.insert(tk.END, f"[{warning['severity'].upper()}]", severity_tag)
                self.results_text.insert(tk.END, f" {warning['type']}\n")
                self.results_text.insert(tk.END, f"   Description: {warning['description']}\n")
                if 'recommendation' in warning:
                    self.results_text.insert(tk.END, f"   Recommendation: {warning['recommendation']}\n")
                self.results_text.insert(tk.END, "\n")
        else:
            self.results_text.insert(tk.END, "✓ No warnings.\n", "success")
        
        # Recommendations
        self.results_text.insert(tk.END, "\n═══ RECOMMENDATIONS ═══\n\n", "low")
        for i, rec in enumerate(self.scan_results["recommendations"], 1):
            self.results_text.insert(tk.END, f"{i}. {rec}\n")
        
        # Summary
        vuln_count = len(self.scan_results["vulnerabilities"])
        warn_count = len(self.scan_results["warnings"])
        
        self.status_label.config(text=f"Scan complete: {vuln_count} vulnerabilities, {warn_count} warnings")
        self.notebook.select(1)  # Switch to results tab
    
    def save_report(self):
        """Save scan report to file"""
        if not self.scan_results:
            messagebox.showwarning("No Data", "Please run a scan first.")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("Text files", "*.txt"), ("All files", "*.*")],
            initialfile=f"security_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        )
        
        if filename:
            try:
                if filename.endswith('.json'):
                    with open(filename, 'w') as f:
                        json.dump(self.scan_results, f, indent=2)
                else:
                    with open(filename, 'w') as f:
                        f.write(self.results_text.get(1.0, tk.END))
                
                messagebox.showinfo("Success", f"Report saved to {filename}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save report: {str(e)}")
    
    def clear_output(self):
        """Clear output text"""
        self.output_text.delete(1.0, tk.END)
        self.results_text.delete(1.0, tk.END)
        self.status_label.config(text="Ready to scan")

def main():
    root = tk.Tk()
    app = SecurityScannerGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
    exit()
